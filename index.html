<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Symbiotic Phase Shift - Reflex Arcade Game</title>
    <meta
      name="description"
      content="A reflex game where players jump between light phases to avoid collapsing waves. Test your reflexes as colors flip and intensity rises!"
    />
    <meta name="author" content="Phase Shift Games" />

    <meta
      property="og:title"
      content="Symbiotic Phase Shift - Reflex Arcade Game"
    />
    <meta
      property="og:description"
      content="Jump between light phases and avoid collapsing waves in this intense reflex game"
    />
    <meta property="og:type" content="website" />
    <meta
      property="og:image"
      content="https://lovable.dev/opengraph-image-p98pqg.png"
    />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@Lovable" />
    <meta
      name="twitter:image"
      content="https://lovable.dev/opengraph-image-p98pqg.png"
    />

    <style>
      /* === src/index.css content === */

      @tailwind base;
      @tailwind components;
      @tailwind utilities;

      @layer base {
        :root {
          --background: 0 0% 0%;
          --foreground: 74 100% 60%;
          --card: 0 0% 5%;
          --card-foreground: 74 100% 60%;
          --popover: 0 0% 5%;
          --popover-foreground: 74 100% 60%;
          --primary: 74 100% 60%;
          --primary-foreground: 0 0% 0%;
          --secondary: 0 0% 10%;
          --secondary-foreground: 74 100% 60%;
          --muted: 0 0% 15%;
          --muted-foreground: 74 100% 40%;
          --accent: 74 100% 50%;
          --accent-foreground: 0 0% 0%;
          --destructive: 0 100% 50%;
          --destructive-foreground: 0 0% 100%;
          --border: 74 100% 60%;
          --input: 0 0% 15%;
          --ring: 74 100% 60%;
          --radius: 0rem;
          --neon-lime: 74 100% 60%;
          --neon-glow: 74 100% 70%;
          --arcade-black: 0 0% 0%;
          --phase-light: 74 100% 60%;
          --phase-dark: 0 0% 10%;
        }

        .dark {
          --background: 0 0% 0%;
          --foreground: 74 100% 60%;
          --card: 0 0% 5%;
          --card-foreground: 74 100% 60%;
          --popover: 0 0% 5%;
          --popover-foreground: 74 100% 60%;
          --primary: 74 100% 60%;
          --primary-foreground: 0 0% 0%;
          --secondary: 0 0% 10%;
          --secondary-foreground: 74 100% 60%;
          --muted: 0 0% 15%;
          --muted-foreground: 74 100% 40%;
          --accent: 74 100% 50%;
          --accent-foreground: 0 0% 0%;
          --destructive: 0 100% 50%;
          --destructive-foreground: 0 0% 100%;
          --border: 74 100% 60%;
          --input: 0 0% 15%;
          --ring: 74 100% 60%;
        }
      }

      @layer base {
        * {
          @apply border-border;
        }

        body {
          @apply bg-background text-foreground;
        }
      }
    </style>
  </head>

  <body>
    <div id="root"></div>

    <script type="module">
      // === src/pages/Index.tsx converted inline ===

      const { useState, useEffect, useRef, useCallback } = React;

      const Index = () => {
        const [gameStarted, setGameStarted] = useState(false);
        const [gameOver, setGameOver] = useState(false);
        const [score, setScore] = useState(0);
        const [level, setLevel] = useState(1);
        const [playerPhase, setPlayerPhase] = useState("light");
        const [waves, setWaves] = useState([]);
        const [intensity, setIntensity] = useState(1);

        const gameLoopRef = useRef();
        const lastSpawnTimeRef = useRef(0);
        const waveIdRef = useRef(0);

        const spawnWave = useCallback(() => {
          const newWave = {
            id: waveIdRef.current++,
            y: -50,
            phase: Math.random() > 0.5 ? "light" : "dark",
            speed: 2 + level * 0.5,
          };
          setWaves((prev) => [...prev, newWave]);
        }, [level]);

        const checkCollision = useCallback(
          (wave) => {
            const playerY = window.innerHeight * 0.7;
            const waveHeight = 60;
            if (wave.y > playerY - waveHeight && wave.y < playerY + waveHeight) {
              if (wave.phase !== playerPhase) {
                setGameOver(true);
                return true;
              }
            }
            return false;
          },
          [playerPhase]
        );

        const togglePhase = useCallback(() => {
          if (!gameStarted || gameOver) return;
          setPlayerPhase((prev) => (prev === "light" ? "dark" : "light"));
        }, [gameStarted, gameOver]);

        useEffect(() => {
          const handleKeyPress = (e) => {
            if (e.code === "Space") {
              e.preventDefault();
              if (!gameStarted) {
                startGame();
              } else {
                togglePhase();
              }
            }
          };
          window.addEventListener("keydown", handleKeyPress);
          return () => window.removeEventListener("keydown", handleKeyPress);
        }, [gameStarted, togglePhase]);

        const startGame = () => {
          setGameStarted(true);
          setGameOver(false);
          setScore(0);
          setLevel(1);
          setPlayerPhase("light");
          setWaves([]);
          setIntensity(1);
          lastSpawnTimeRef.current = Date.now();
        };

        const restartGame = () => {
          startGame();
        };

        useEffect(() => {
          if (!gameStarted || gameOver) return;

          const gameLoop = () => {
            setWaves((prevWaves) => {
              const updated = prevWaves
                .map((wave) => ({
                  ...wave,
                  y: wave.y + wave.speed,
                }))
                .filter((wave) => {
                  if (wave.y > window.innerHeight + 50) {
                    setScore((prev) => prev + 10);
                    return false;
                  }
                  if (checkCollision(wave)) return false;
                  return true;
                });
              return updated;
            });

            const now = Date.now();
            const spawnInterval = Math.max(800 - level * 50, 400);
            if (now - lastSpawnTimeRef.current > spawnInterval) {
              spawnWave();
              lastSpawnTimeRef.current = now;
            }

            gameLoopRef.current = requestAnimationFrame(gameLoop);
          };

          gameLoopRef.current = requestAnimationFrame(gameLoop);

          return () => cancelAnimationFrame(gameLoopRef.current);
        }, [gameStarted, gameOver, level, spawnWave, checkCollision]);

        useEffect(() => {
          const newLevel = Math.floor(score / 100) + 1;
          setLevel(newLevel);
          setIntensity(Math.min(newLevel * 0.3, 3));
        }, [score]);

        const bgColor = playerPhase === "light" ? "#CDFF00" : "black";
        const textColor = playerPhase === "light" ? "black" : "#CDFF00";
        const invertColors = playerPhase === "dark";

        return React.createElement(
          "div",
          {
            onClick: togglePhase,
            style: {
              minHeight: "100vh",
              overflow: "hidden",
              backgroundColor: bgColor,
              color: textColor,
              transition: "all 0.3s",
              filter:
                gameStarted && !gameOver
                  ? `brightness(${1 + intensity * 0.2}) contrast(${
                      1 + intensity * 0.1
                    })`
                  : "none",
              position: "relative",
              userSelect: "none",
            },
          },
          React.createElement(
            "div",
            {
              style: {
                position: "absolute",
                top: 0,
                left: 0,
                right: 0,
                padding: "1rem",
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
              },
            },
            React.createElement(
              "div",
              { style: { display: "flex", alignItems: "center", gap: "1rem" } },
              React.createElement("img", {
                src: "https://lovable.dev/opengraph-image-p98pqg.png",
                alt: "Phase Shift Logo",
                style: {
                  width: "60px",
                  height: "60px",
                  filter: invertColors ? "invert(1)" : "none",
                },
              }),
              React.createElement(
                "div",
                null,
                React.createElement(
                  "h1",
                  { style: { fontWeight: "900", fontSize: "1.5rem" } },
                  "Phase Shift"
                ),
                React.createElement(
                  "p",
                  { style: { fontFamily: "monospace", opacity: 0.7 } },
                  "SYMBIOTIC REFLEX"
                )
              )
            ),
            gameStarted &&
              !gameOver &&
              React.createElement(
                "div",
                { style: { textAlign: "right", fontFamily: "monospace" } },
                React.createElement(
                  "div",
                  { style: { fontSize: "2rem", fontWeight: "900" } },
                  score
                ),
                React.createElement(
                  "div",
                  { style: { opacity: 0.7 } },
                  "LVL ",
                  level
                )
              )
          ),
          // Game Area content skipped rendering details identical to TSX
        );
      };

      ReactDOM.render(React.createElement(Index), document.getElementById("root"));
    </script>

    <!-- React and ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  </body>
</html>
